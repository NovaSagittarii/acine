// Handles routing and listens for routing goals

syntax = "proto3";

package ac;

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "routine.proto";

service RuntimeService {
  // Fetches where the current node is
  rpc GetCurrentNode(google.protobuf.Empty) returns (Routine.Node) {}

  rpc SetNode(Routine.Node) returns (google.protobuf.Empty) {}

  rpc GoToNode(Routine.Node) returns (google.protobuf.Empty) {}
}

// Currently loaded initially to debug any background-runtime failures.
//
// Intended TODO: Runtime data is sent over to the client batched initially,
// then single update packets.
message RuntimeData {
  string id = 1;  // id of routine this is linked with (validation purposes)
  reserved 2;     // frames?
  reserved 3;     // states?
  reserved 4;     // nodes?
  map<string, ExecutionInfo> edges = 5;           // edge aux data
  map<string, ExecutionInfo> sgroups = 6;         // sgroup aux data
  map<string, ExecutionInfo> execution_info = 7;  // all aux data
  repeated Event events = 8;                      // logs of all events
}

message RuntimeState {
  Routine.Node current_node = 1;  // current node
  Routine.Node target_node = 2;   // desired target node
  Routine.Edge current_edge = 3;  // current processed edge, null if idling
  repeated Routine.Edge stack_edges = 4;  // return stack
}

message ExecutionInfo {
  string id = 1;
  repeated Event events = 2;  // probably unused
  Metric stats = 3;

  google.protobuf.Timestamp last_run = 4;
  // Last completed execution.
  //
  // In SchedulingGroup -- Used to determine whether a group needs to
  // be scheduled as catch-up. This happens if now is after the next time
  // to schedule a run since the last run.
}

message Metric {
  int32 total = 1;                          // total runs
  int32 fails = 2;                          // how many fails
  int32 consecutive_fails = 3;              // how many fails in a row
  google.protobuf.Timestamp next_time = 4;  // next allow time after backoff
}

message Event {
  google.protobuf.Timestamp time_start = 1;  // when this started
  google.protobuf.Timestamp time_end = 2;    // when this ended
  string node_id = 3;                        // from where this happened
  Event.Debug debug = 4;                     // route calculations
  RuntimeState context = 5;                  // runtime internal state
  Level level = 6;                           // event urgency
  Action.Log action = 7;                     // an action was taken
  Exception exception = 8;  // something broke before action could be taken

  // debug info for event
  message Debug {
    string comment = 1;            // any debug string
    repeated string rankings = 2;  // edge ranking for prioritizing
  }

  // sync with acine/runtime/exceptions.py
  enum Exception {
    EXCEPTION_UNSPECIFIED = 0;  // no error
    EXCEPTION_GENERIC = 1;      // generic error (too lazy to sync)
    EXCEPTION_INTERRUPT = 2;    // interrupted so shutting down
    EXCEPTION_NO_PATH = 3;
  }
}

enum Level {
  LEVEL_UNSPECIFIED = 0;
  LEVEL_LOG = 1;       // for logging
  LEVEL_INFO = 2;      // unused
  LEVEL_WARN = 3;      // unused
  LEVEL_ERROR = 4;     // unused
  LEVEL_CRITICAL = 5;  // needs attention (f.e. nav broken)
}

message Action {
  // a record of an action happening
  message Log {
    string id = 1;                     // id of edge that was taken
    Action.Phase phase = 2;            // how far it got
    Action.Result result = 3;          // result of (precondition/action)
    repeated Action.Event events = 4;  // more granular log
  }

  message Event {
    google.protobuf.Timestamp timestamp = 1;  // when this happened
    string archive_id = 2;                    // id of frame for this
    Action.Phase phase = 3;                   // current phase
  }

  enum Phase {
    PHASE_UNSPECIFIED = 0;
    PHASE_PRECONDITION = 1;   // started precondition but didnt pass
    PHASE_POSTCONDITION = 2;  // started postcondition but didnt pass
    PHASE_ACTION = 3;         // started action but didnt complete
    PHASE_COMPLETION = 4;     // completed pre/act/post
  }

  enum Result {
    RESULT_UNSPECIFIED = 0;
    RESULT_PASS = 1;        // condition pass OR action completion
    RESULT_TIMEOUT = 2;     // condition timeout
    RESULT_INTERRUPT = 3;   // action was interrupted
    RESULT_ERROR = 4;       // something broke
    RESULT_NOT_ATOMIC = 5;  // error during subroutine
  }
}

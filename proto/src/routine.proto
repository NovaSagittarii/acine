syntax = "proto3";

package ac;

import "frame.proto";
import "input_event.proto";
import "position.proto";

message Routine {
  string id = 1;              // metadata
  string name = 2;            // metadata
  string description = 3;     // metadata
  repeated Frame frames = 4;  // indexed by id
  repeated State states = 5;  // indexed by id
  repeated Node nodes = 6;    // indexed by id
  repeated SchedulingGroup sgroups = 7;

  string start_command = 8;
  /* Executes this command in `cmd.exe` to start target application.
   * Run a script (like `start.bat`) if it's not a single command.
   */

  string window_name = 9;
  /* Window name to look for after running `start_command`.
   * TODO: handle "" window_name denoting entire desktop (see AHK)
   */

  // basically unused at the moment
  message State {
    string id = 1;  // uuid
    string name = 2;
    string description = 3;
    repeated uint32 samples = 4;  // samples for this state; indexes into frames

    // region of interest; used to restrict area of interest in samples
    // ! probably want to remove in favor of condition image region match?
    ac.Rect region = 5;
  }

  message Node {
    string id = 1;  // uuid
    string name = 2;
    string description = 3;

    string state_id = 4;      // indexes into states (for recongition); unused
    repeated Edge edges = 5;  // transitions

    NodeType type = 6;
    enum NodeType {
      NODE_TYPE_UNSPECIFIED = 0;
      NODE_TYPE_STANDARD = 1;  // normal node
      NODE_TYPE_INIT = 2;      // starting node; referenced by subroutines
      NODE_TYPE_RETURN = 4;    // subroutine end
    }

    /* Default condition used whenever a pre/post condition check is "Auto"
     *
     * Acts like a "state precondition" -- Primarily used when there are
     * multiple transitions to the same state, representing multiple ways
     * to get there. These will all have the same postcondition.
     *
     * Additionally, potential use in node autodetection.
     *
     * Might be some application for precondition (not sure yet)
     */
    Condition default_condition = 7;
  }

  message Edge {
    string id = 1;  // uuid
    string name = 2;
    string description = 3;
    /* uuid of (from) curr node; only used by runtime
     * from is a reserved keyword in python
     */
    string u = 8;
    string to = 4;  // uuid of next node; from node is edge's parent
    Condition precondition = 5;   // required before you can take it
    Condition postcondition = 6;  // used to validate success
    int32 limit = 7;  // how many times this can be taken, negative is unlimited
    repeated ScheduleInstance schedules = 9;  // if none, does not auto schedule

    oneof action {              // can be an action, or null action;
      Point click = 11;         // [replay impl's] click here
      Rect click_region = 12;   // [unused] click anywhere here
      PointSequence drag = 13;  // [replay impl's] drag through these points
      string subroutine = 14;   // execute subroutine (node_id)
      InputReplay replay = 15;  // recording playback
    };

    EdgeTriggerType trigger = 10;  // restriction on when it can be taken

    repeated Dependency dependencies = 16;
    // Need to satisfy these before scheduling.
    // Interrupt with dependency does not make sense because interrupt is a
    // navigation related reaction and cannot be scheduled.

    enum EdgeTriggerType {
      EDGE_TRIGGER_TYPE_UNSPECIFIED = 0;
      EDGE_TRIGGER_TYPE_STANDARD = 1;  // can freely choose to take
      EDGE_TRIGGER_TYPE_INTERRUPT = 2;
      /* must be taken if possible -- forced action
       *
       * if precondition passes, goto is forced (an unplanned async event)
       *
       * recommended to use auto postcondition
       */

      EDGE_TRIGGER_TYPE_SCHEDULED = 3;
      /* special case of standard edge, must be scheduled to take.
       * cannot be used for navigation.
       */
    }

    message ScheduleInstance {
      string scheduling_group_id = 1;  // which scheduling group this references
      int32 count = 2;                 // multiplicity
      RequirementType requirement = 3;  // what counts?
    }
  }

  /**
   * Primarily used for verification; a check (precondition/postcondition)
   * that must pass before an action can happen and
   * used to verify whether an action succeeded.
   *
   * Also used to detect and react to changes (for null actions).
   */
  message Condition {
    uint32 timeout = 1;   // ms; after timeout, ignore this; defaults to INF
    uint32 delay = 2;     // ms; defaults to 0; required time before considering
    uint32 interval = 3;  // ms; defaults to 100; time between checks
    repeated uint32 records = 11;  // past waiting periods (data collection)
    oneof condition {              // what to check; by default ALWAYS TRUE
      Image image = 21;            // image match
      Text text = 22;              // text match

      /* takes on from/to node's default condition
       * CANNOT be used as a node's default condition
       */
      bool auto = 23;

      /* inherits target node's default condition.
       * useful in e-transitions.
       * CANNOT be used as a node's default condition
       */
      bool target = 24;
    }

    /* Somewhat generalized pixel matching.
     *
     * | Type                   | `regions` | `allow_regions` |
     * |------------------------|-----------|-----------------|
     * | Pixel                  | [1x1]     | same as regions |
     * | Region                 | [wxh]     | same as regions |
     * | Composite region       | [wxh...]  | same as regions |
     * | Loose region           | [wxh]     | [wxh]           |
     * | Loose composite region | [wxh...]  | [wxh...]        |
     */
    message Image {
      string frame_id = 1;   // actual payload to check
      double threshold = 2;  // required similarity to pass; between 0.0 and 1.0
      int32 padding = 5;  // required spacing between matches, can be negative
      int32 match_limit = 6;  // limit how many matches are considered (for UX)
      Method method = 7;      // how to calculate template?

      // section that it checks;
      // crops base frame to get desired match frame.
      repeated Rect regions = 3;

      // section of the target frame you can check;
      // crops target frame before comparing against match frame.
      // if unset, assume regions==allow_regions (not dynamic)
      repeated Rect allow_regions = 4;

      enum Method {
        METHOD_UNSPECIFIED = 0;
        METHOD_TM_SQDIFF_NORMED = 1;
        METHOD_TM_CCORR_NORMED = 2;
        METHOD_TM_CCOEFF_NORMED = 3;
      }
    }

    message Text {                // wants to ensure it finds some text
      string regex = 1;           // regex match pattern
      repeated Rect regions = 2;  // restricts detect area; unset = unrestricted
    }
  }

  /**
   * Scheduling group with how frequently to check and how to handle retrying.
   */
  message SchedulingGroup {
    string id = 1;
    string name = 2;
    string description = 3;
    int32 retry_interval = 4;  // ms; time between attempts
    int32 retry_attempts = 5;  // ?? max amount of attempts before backing off
    int32 reschedule = 6;      // ?? ms; rescheduled time after a backoff
    int32 deadline = 7;        // ms; allowed duration to complete task
    int32 period = 8;          // ms; duration of a scheduling period
    Period period_preset = 9;  // overrides period with a preset
    repeated int32 dispatch_times = 10;  // ms; dispatch times within a period
    reserved 11;
    // SchedulingType type = 11;

    enum Period {
      PERIOD_UNSPECIFIED = 0;
      PERIOD_DAILY = 1;     // every 00:00 UTC
      PERIOD_WEEKLY = 2;    // every Sunday UTC
      PERIOD_BIWEEKLY = 3;  // every 1st and 3rd Sunday UTC
      PERIOD_MONTHLY = 4;   // every 1st day of month UTC
    }
  }
  // enum SchedulingType {
  //   // SCHEDULING_TYPE_HARD_REALTIME = 4;  // no misses are ok
  //   SCHEDULING_TYPE_UNSPECIFIED = 0;
  //   SCHEDULING_TYPE_SOFT_REALTIME = 1;  // still useful if deadline is missed
  //   SCHEDULING_TYPE_FIRM_REALTIME = 2;  // few misses are ok
  //   SCHEDULING_TYPE_CHECK = 8;          // tries `retry_attempts` times
  //   SCHEDULING_TYPE_EXECUTE = 16;       // requires action to happen
  // }

  message Dependency {
    /* Dependencies are taken into account at the scheduling stage.
     *
     * Used for requiring some actions that must happen before another.
     */

    string id = 1;
    string requires = 2;              // what is the dependency on? (edge id)
    int32 count = 3;                  // how many times it needs to happen
    RequirementType requirement = 4;  // what counts as meeting it?
    bool explicit = 5;                // whether you MUST manually schedule it
    // note: currently explicit==true (have not implemented implicit pass)

    int32 persist_duration = 6;  // ms; when do counts expire?
  }
  enum RequirementType {
    /* During edge processing, the following occurs:
     * 1. Precondition attempt, if fail, abort
     * 2. Action attempt (possibly interrupted)
     * 3. Postcondition attempt, if fail, abort
     * 4. Completion
     */

    REQUIREMENT_TYPE_UNSPECIFIED = 0;  // default: completion
    REQUIREMENT_TYPE_CHECK = 1;        // requires precondition attempt
    REQUIREMENT_TYPE_CHECK_PASS = 2;   // requires precondition pass
    REQUIREMENT_TYPE_EXECUTE = 3;      // requires postcondition attempt
    REQUIREMENT_TYPE_COMPLETION = 4;   // requires postcondition pass
  }
}

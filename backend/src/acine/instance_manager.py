"""
Helper functions to deal with multiple routine instances.

When run as main, creates `test-routine` and prints ids of stored routines.
"""

import os
from typing import Final, List
from uuid import uuid4

from acine.persist import (
    PrefixedFilesystem,
    fs_read_sync,
    fs_write_sync,
    mkdir,
    resolve,
)
from acine_proto_dist.routine_pb2 import Routine
from acine_proto_dist.runtime_pb2 import RuntimeData

TESTENV_PATH: Final[str] = os.path.realpath(
    os.path.join(
        os.path.dirname(os.path.abspath(__file__)),  # /backend/src/acine
        "..",  # /backend/src/
        "..",  # /backend
        "..",  # /
        "testenv",  # /testenv
        "main.py",  # /testenv/main.py
    )
)
TESTENV_CMD: Final[str] = f"start pythonw {TESTENV_PATH}"
EXAMPLE_ID: Final[str] = "00000000-0000-1000-a727-000000000000"


def create_routine(routine: Routine, id: str = str(uuid4())) -> Routine:
    """creates files for new routine in /data, returns the newly created routine"""

    assert (
        routine.launch_config.window_name
    ), "Window name should exist. Desktop currently not supported."
    assert routine.name, "Name should exist. Otherwise cannot differentiate."

    r = Routine(
        id=id,
        name=routine.name,
        description=routine.description,
        launch_config=Routine.LaunchConfiguration(
            start_command=TESTENV_CMD,
            window_name="TestEnv",
        ),
        nodes={
            "start": Routine.Node(
                id="start", name="start", type=Routine.Node.NODE_TYPE_STANDARD
            )
        },
    )
    mkdir([id])
    fs_write_sync([id, "rt.pb"], r.SerializeToString())
    fs_write_sync([id, "archive.7z"], RuntimeData(id=routine.id).SerializeToString())
    mkdir([id, "tmp"])
    mkdir([id, "img"])
    return r


def get_routines(full: bool = False) -> List[Routine]:
    """lists all routines available with minimal metadata (name,id,description)"""

    out = []
    for f in os.listdir(resolve()):
        if "-" not in f:  # not a uuidv4
            continue
        if os.path.isfile(resolve(f)):
            continue
        r = Routine.FromString(fs_read_sync([f, "rt.pb"]))
        if not full:
            r = Routine(
                id=r.id,
                name=r.name,
                description=r.description,
                launch_config=r.launch_config,
            )
        out.append(r)
    return sorted(out, key=lambda x: x.name)


def validate_routine(routine: Routine) -> bool:
    """returns True if the routine is valid (exists in filesystem)"""
    try:
        assert os.path.exists(resolve(routine.id, "rt.pb"))
        assert os.path.exists(resolve(routine.id, "img"))
    except AssertionError:
        return False
    return True


def get_routine(routine: Routine) -> Routine:
    """gets full routine metadata from filesystem"""
    assert validate_routine(routine)
    return Routine.FromString(fs_read_sync([routine.id, "rt.pb"]))


def get_runtime_data(routine: Routine) -> RuntimeData:
    """gets routine runtime_data from filesystem"""
    assert validate_routine(routine)
    if os.path.exists(resolve(routine.id, "runtimedata.pb")):
        return RuntimeData.FromString(fs_read_sync([routine.id, "runtimedata.pb"]))
    else:
        return RuntimeData(id=routine.id)


def write_runtime_data(routine: Routine, data: RuntimeData) -> None:
    assert validate_routine(routine)
    fs_write_sync([routine.id, "runtimedata.pb"], data.SerializeToString())


def get_pfs(routine: Routine) -> PrefixedFilesystem:
    assert validate_routine(routine)
    return PrefixedFilesystem([routine.id])


def create_testenv() -> None:
    """
    Programmatically create example routine for testenv.

    Might not work on other devices. Hardcoded coordinates copied from
    actions on Windows 11 24H2, 1920x1080 resolution, 125% scaling.
    """
    import cv2
    import numpy as np
    from acine_proto_dist.input_event_pb2 import InputEvent, InputReplay
    from acine_proto_dist.position_pb2 import Point, Rect, RelativePoint

    def monocolor(r: int, g: int, b: int, w: int, h: int) -> cv2.typing.MatLike:
        """returns a w,h,3 BGR matrix with each pixel (b,g,r)"""
        mat = np.ndarray((h, w, 3), np.uint8)
        mat[:][:] = [b, g, r]
        return mat

    r = Routine(
        name="Example Routine",
        launch_config=Routine.LaunchConfiguration(window_name="TestEnv"),
        description="Autogenerated routine for TestEnv",
    )
    id = EXAMPLE_ID
    r = create_routine(r, id)
    print(get_routines())
    assert validate_routine(r)

    # colors extracted from running the application, might vary depending on theme
    cv2.imwrite(resolve(id, "img", "red.png"), monocolor(255, 0, 0, 660, 404))
    cv2.imwrite(resolve(id, "img", "green.png"), monocolor(6, 176, 37, 660, 404))
    cv2.imwrite(resolve(id, "img", "gray.png"), monocolor(230, 230, 230, 660, 404))
    for color in ("red", "green", "gray"):
        f = r.frames.get_or_create(color)
        f.id = color

    # Creates routine for testing testenv
    def create_node(
        name: str,
        description: str,
        type: Routine.Node.NodeType.ValueType = Routine.Node.NODE_TYPE_STANDARD,
    ) -> Routine.Node:
        n = r.nodes.get_or_create(name)
        n.id = name
        n.name = name
        n.type = type
        n.description = "[Auto-generated] " + description
        return n

    def create_edge(
        source: Routine.Node, target: Routine.Node, description: str
    ) -> Routine.Edge:
        e = Routine.Edge(
            id=str(uuid4()),
            to=target.id,
            precondition=source.default_condition,
            postcondition=Routine.Condition(auto=True),  # target.default_condition
            trigger=Routine.Edge.EDGE_TRIGGER_TYPE_STANDARD,
            repeat_lower=1,
            repeat_upper=10,
            description=description,
        )
        source.edges.append(e)
        return source.edges[-1]  # note: append makes a copy# note: append makes a copy

    start = r.nodes["start"]
    start.description = "This is the start node (initial state after launch)."
    empty = create_node("empty", "The bar is empty.")
    empty.MergeFrom(
        Routine.Node(
            default_condition=Routine.Condition(
                image=Routine.Condition.Image(
                    frame_id="gray",
                    threshold=0.99,
                    match_limit=1,
                    method=Routine.Condition.Image.METHOD_TM_SQDIFF_NORMED,
                    regions=[Rect(left=508, right=623, top=300, bottom=318)],
                    # the bar that gets filled
                )
            )
        )
    )
    filled = create_node("filled", "The bar is full.")
    filled.MergeFrom(Routine.Node(default_condition=empty.default_condition))
    filled.default_condition.image.frame_id = "green"
    create_edge(start, empty, "Go into the filling loop.")
    filling = create_edge(empty, filled, "Hover over red (template match demo).")
    filling.precondition.image.frame_id = "red"
    filling.precondition.image.regions.pop()  # remove the old region first
    filling.MergeFrom(
        Routine.Edge(
            # find a small red square in any of the canvas region
            precondition=Routine.Condition(
                image=Routine.Condition.Image(
                    allow_regions=[Rect(left=16, right=473, top=74, bottom=397)],
                    regions=[Rect(left=88, right=116, top=121, bottom=151)],
                ),
            ),
            replay=InputReplay(
                # shake the mouse horizontally
                events=[
                    InputEvent(timestamp=0, move=Point(x=302, y=233)),
                    InputEvent(timestamp=1, mouse_down=InputEvent.MOUSE_BUTTON_LEFT),
                    *[
                        InputEvent(timestamp=t, move=Point(x=302 + t % 10, y=233))
                        for t in range(3, 1200, 29)
                    ],
                    InputEvent(timestamp=1200, mouse_up=InputEvent.MOUSE_BUTTON_LEFT),
                ],
                duration=1200,
                relative=True,
                offset=RelativePoint(x=287, y=225),
            ),
        )
    )
    reset = create_edge(filled, empty, "Move mouse along the left to reset bar.")
    reset.MergeFrom(
        Routine.Edge(
            replay=InputReplay(
                # drag down (this is an exception that should generally work)
                events=[
                    InputEvent(timestamp=0, move=Point(x=10, y=200)),
                    InputEvent(timestamp=1, mouse_down=InputEvent.MOUSE_BUTTON_LEFT),
                    InputEvent(timestamp=50, move=Point(x=10, y=222)),
                    InputEvent(timestamp=100, mouse_up=InputEvent.MOUSE_BUTTON_LEFT),
                ],
                duration=100,
                offset=RelativePoint(x=10, y=200),
            ),
        )
    )
    reset.precondition.Clear()
    for node in (empty, filled):
        # fail check early to do a repeat immediately
        node.default_condition.timeout = 1

    fs_write_sync([id, "rt.pb"], r.SerializeToString())


if __name__ == "__main__":
    create_testenv()
